'''
:author: Robin Flume
:contact: robin.flume@rub.de
'''

from pgf.log.logger import Logger
from pgf.analysis.fileparser.abstract_parser import InputParser

# change the classname!
# We use the convention of naming the class like this:
# [InputformatType]
# E.g.:
# PlaintextPure         (One password per line)
# PlaintextColon        ('Username:Password')
# HashPure              (One hash value per line)
# PlaintextWithcount    (Withcount format: '  1234 MyPassword')

class Template(InputParser):
    ''' Parser for files containing one plaintext password per line.
    '''

    def __init__(self, pw_file):
        ''' Generator. 
        '''

        # don't change the __init__ method!

        # Initiate logger
        self.logger = Logger()
        self.logger.basicConfig('DEBUG')        # set logger level to DEBUG
        
        # initiate variables
        self.pw_file = pw_file                  # path of the input file
        self.pw_counter = 0                     # counter for the amount of passwords in the leak
        self.error_counter = 0                  # counter for the errors occuring during the file-parsing
        self.pws_multi = {}                     # Dict to store the passwords from the file including an occurence-counter for each password


    def get_filetype(self):
        ''' Return the input type indicator to run the according analysis module and the execution module correctly.
        '''

        # uncomment the return value according to your input type.

        return 'hashvalues'
#        return 'plaintext'


    def parse_pw_file(self):
        ''' Parses the passwords (plaintext) from the password leak and analyzes the occurences of the passwords.

        :requires: One password per line in the file.
        
        :return: (Dict{'occ', 'lookups'}, Int, Int): Dict containing the parsed passwords and a dict of their occurences in the leak ('occ') as well as a counter for the amount of lookups ('lookups') which is used to count the amout of duplicate candidates that might be generated by a guesser. The integers are a password counter and a parsing-error counter.
        '''

        self.logger.debug("Start parsing the password file ...")

        f = open(self.pw_file, 'rU')                    # open the password file
        if f is None:
            self.logger.debug("The pw file could not be opened!\nAnalysis closed!")
            exit(-1)

        for line in f:
            try:
                self.pw_counter += 1                    # increment counter
                
                # The main changes have to be done here.
                # Parse the lines in the file and extract the password/hash value
                #
                # It is important to only parse the plaintext password or the UNSALTED hashvalue.
                # JtR will evaluate the salt as well of course, but the analysis module is not (yet) 
                # capable of processing the salt.
                #
                # Parsing a pure plaintext leak:
                # --> pw = line[:len(line)-1]       (removing the '\n' character from the plaintext password)
                #
                # Parsing a plaintext leak containing lines "username:password":
                # --> splitted = line.split(':')          (split the line with seperator ':')
                # --> pw = ':'.join(splitted[1:])[:-1]    (concatenate splitted parts again with ':' as sepeperator)
                #                            ^     ^           
                #                            |     |
                #                            |  remove '\n' character
                #                remove first element (username (which MUST NOT contain ':' for correct parsing))   
                #
                # The following part remains the same if the occurences (as in withcount format) is not included in the line itself.
                # For withcount formats, also parse the counter and apply the following change below:
                '''
                if pw not in self.pws_multi:
                    self.pws_multi[pw] = {'occ':1, 'lookups':0}         # add a dict to the dict-entry [pw] with init values 1 and 0
                else:
                    self.pws_multi[pw]['occ'] += 1                      # increment occurence counter for the current password
                '''
                # --> is to be replaced with:
                '''
                # counter = [PARSE THE COUNTER FROM LINE HERE]
                self.pws_multi[pw] = {'occ':counter, 'lookups':0}       # add a dict to the dict-entry [pw] with init values 1 and 0
                '''
                # Note that 'pw' would be the hash value for hashed passwords.
                # Explanation:
                # Each password/hash (key of the dictionary) has a second dictionaly as value, storing an 
                # occurence counter (accessable via: self.pws_multi['MyPassword']['occ']) and a 
                # lookup counter (accessable via: self.pws_multi['MyPassword']['lookups']).
                # The latter is used to identify multiple guesses made by the guesser in the analysis module.
                # The occurrence counter is needed to check how many passwords a

                if pw not in self.pws_multi:
                    self.pws_multi[pw] = {'occ':1, 'lookups':0}         # add a dict to the dict-entry [pw] with init values 1 and 0
                else:
                    self.pws_multi[pw]['occ'] += 1                      # increment occurence counter for the current password
            except:
                self.error_counter += 1                 # silently ignore decode-errors but count it
        f.close()                                       # close the file
        self.logger.debug("Parsing done!")
        return self.pws_multi, self.pw_counter, self.error_counter
